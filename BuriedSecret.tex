%
% Niniejszy plik stanowi przyk³ad formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet u¿ytych poleceñ mo¿na wykorzystywaæ do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrze¿one.
%
% Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Kar³owicz, 05.05.2006

\documentclass[licencjacka]{pracamgr}

\usepackage{polski}

\usepackage[utf8]{inputenc}

\usepackage{pdfpages}

\usepackage{gensymb}


% Dane licencjanta:

\author	{Imię Nazwisko}

\nralbumu{666999}

\title{Implementacja taktycznej gry fabularnej czasu rzeczywistego}

\tytulang{An implementation of a real-time strategy role-playing game}

\kierunek{Informatyka}

\opiekun{mgra Radosława Bartosiaka\\
  Instytut Informatyki\\
  }

% miesiąc i rok:
\date{Maj 2015}

\dziedzina{11.3 Informatyka}

%Klasyfikacja tematyczna wedlug ACM (informatyka)
\klasyfikacja{D. Software}

\keywords{gra, gra komputerowa, qt, sfml, box2d, taktyczna gra fabularna}

% Tu jest dobre miejsce na Twoje własne makra i środowiska:
% \newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  Niniejsza praca opisuje taktyczną grę fabularną stworzoną
  w~ramach przedmiotu Zespołowy Projekt Programistyczny.
  W~szczególności opisane zostało projektowanie silnika,
  mechaniki oraz~interfejsu gry. Praca zawiera również 
  opis osiagniętego rezultatu wraz z~wynikiem przeprowadzonych testów.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}
% Tutaj jakieś mega słowa generalne o grze + o strukturze pracy, rozdziały, załączniki? i takie tam

\chapter{Projekt}

  \section{Opis projektu}
  Zgodnie z zamówieniem klienta, realizowany projekt miał polegać na stworzeniu gry komputerowej
  średnich rozmiarów. Ze względu na skład zespołu, złożonego wyłącznie z programistów, skupiliśmy się 
  na dostarczeniu rozbudowanego, w pełni funkcjonalnego silnika gry.
  Docelowa aplikacja miała być grywalnym produktem, prezentującym możliwości zaimplementowanego silnika,
  bez contentu i grafiki na poziomie konkurencyjnych, komercyjnych gier. Dodatkowym wymogiem było zrealizowanie
  projektu, w sposób umożliwiający dystrybucję na wielu systemach operacyjnych (Windows, Linux). Aby uniknąć 
  tworzenia wielkiej gry bez możliwości ukończenia jej w realistycznym czasie, silnik miał być łatwo skalowalny 
  i pozwolić na realizację zarówno małych jak całkiem dużych gier.

  \section{Założenia projektowe}
  W pierwszej fazie projektu wybrana została ogólna koncepcja gry, z której wynikają dalsze postanowienia dotyczące 
  tworzonego silnika. Zdecydowaliśmy się na realizację gry taktycznej, czasu rzeczywistego. Rola gracza ma polegać
  na sterowaniu niewielką grupą unikalnych postaci i realizowaniu kolejnych misji. Postęp gry jest wynikiem kończenia 
  kolejnych, powiązanych ze sobą poziomów. Każdy z nich może wprowadzać pewne wątki fabularne. Poza głównymi zadaniami, 
  decydującymi o zakończeniu misji sukcesem, gracz może realizować także zadania poboczne, nie mające wpływu na 
  postęp fabularny gry. Główną trudnością ma być utrzymanie postaci przy życiu, podczas ataków wrogich jednostek.
  Mechanika systemu powinna skłaniać gracza do przemyślanych, taktycznych działań, bez testowania jego zdolności 
  szybkiego klikania. Równocześnie staramy się uniknąć zbyt pasywnej postawy użytkownika. 

  \section{Grupa docelowa}
  Aby uzyskać jak najwięcej informacji zwrotnych na temat naszego systemu, postanowiliśmy skierować nasz system do
  graczy komputerowych zainteresowanych grami taktycznymi, wymagającymi myślenia. Głównym źródłem satysfakcji
  odbiorcy ma być ciekawa mechanika i rozwiązywanie problemów strategicznych. Wyzwania gry powinny być realizowane przez
  odpowiednią konstrukcję poszczególnych poziomów i konieczność dostosowywania się do zmiennej sytuacji na planszy.

  \section{Osadzenie rozgrywki}
  Gra osadzona jest w niedalekiej przyszłości, około roku 2050, w świecie lekko fantastycznym, wzorowanym na
  rzeczywistym. W wyniku silnych ruchów tektonicznych na terenie Australii, ujawniony zostaje rodzaj tunelu
  prowadzącego w głąb Ziemi. Organizacje międzynarodowe decydują się wysłać ekspedycję, która zbada to niezwykłe
  zjawisko. Pierwsza ekspedycja odkrywa gigantyczne kompleksy jaskiń, które wyglądają na stworzone przez człowieka.
  Po dalszych badaniach odkrywają, że głębsze jaskinie są zamieszkane przez rasę nieznaną ludzkości. Niedługo
  po tym odkryciu, kontakt z pierwszą ekspedycją urywa się. Pod wpływem tych niecodziennych zdarzeń, najróżniejsze
  instytucje decydują się na podjęcie badań na własną rękę. Jak się okazuje, podobne tunele istnieją na całym świecie,
  ukryte w najdziwniejszych miejscach. Dopiero ostatni skok technologiczny pozwolił na ich wykrycie. Wysłana zostaje
  druga oficjalna ekspedycja, której przewodził będzie gracz. Po osiągnięciu pewnej głębokości, zaczynają pojawiać się
  problemy z łącznością. Kontakt z powierzchnią jest rzadki i zakłócony. Po dotarciu do pierwszych, pustych już zabudowań
  dziwnej cywilizacji, ekspedycja dzieli się na dwie części, bazę badawczą, która pozostaje na miejscu i ma umożliwić
  pracę drugiej części, która zapuszcza się głębiej. Dość szybko druga część zostaje zaatakowana przez nieznane stwory,
  które mordują większość członków ekspedycji i odcinają możliwość powrotu. Gracz wciela się w dowódcę odciętego
  oddziału, który musi poradzić sobie z trudną sytuacją i odkryć, co stało się z pierwszą wyprawą i kim są nieznane
  stwory. Członkowie wyprawy szybko zauważają, że nie są jedynymi, którzy postanowili zbadać podziemne miasta.
  
  \section{Mechanika}
    \subsection{Rola gracza}
    Gracz steruje jednym oddziałem poruszającym się po zabudowanych, wielkich kompleksach jaskiń. Powoli przenosząc
    swój obóz i zabezpieczając się przed atakami, oddział musi poruszać się do przodu, aby realizować kolejne, stawiane
    sobie zadania. Gracz może kazać każdemu z członków ekspedycji przemieszczać się po planszy, przejmować budynki lub
    tworzyć prowizoryczne konstrukcje obronne. Oprócz tego, zarządza ich ekwipunkiem i wydaje rozkazy dotyczące reagowania
    na zagrożenie. Ze względu na braki żywności i rosnące zagrożenie, gracz musi wykonywać misje szybko, starając się
    nie stracić taktycznej przewagi nad otaczającymi go wrogimi jednostkami.
    
    \subsection{Elementy gry}
    \paragraph{Plansza}
      Każdy level jest rozgrywany na osobnej planszy, przedstawiającej jakiś fragment podziemia, zamieszkałego przez
      obcą cywilizację. Składa się ona z grafiki tła, ścian jaskiń i umieszczonych w wolnych przestrzeniach obiektów gry.
    \paragraph{Budynki}
      Jednym z najważniejszych elementów gry są budynki. Służą one graczowi do przejmowania taktycznej przewagi na danym
      terenie, umożliwiając skuteczniejszy ostrzał okolicy i pozwalając bezpiecznie przechować swoje jednostki. Oprócz tego,
      w budynkach znajdują się różnego rodzaju przedmioty.
    \paragraph{Konstrukcje obronne}
      Konstrukcje obronne są obiektami tworzonymi i stawianymi na planszy przez postaci. Służą poprawieniu sytuacji
      taktycznej gracza na danym obszarze. Niektóre z nich, mogą wymagać do swego działania operatora – postaci która
      do nich ,,wejdzie''. Konstrukcje są budowane przez postaci z elementów znalezionych w budynkach. Konstrukcje mogą
      zostać złożone i przeniesione w nowe miejsce.
    \paragraph{Postaci}
      Postaci reprezentują pojedynczych członków ekspedycji. Mogą oni należeć do ekspedycji dowodzonej przez gracza,
      wtedy ma on nad nimi kontrolę, lub innej, dowodzonej przez AI. Każda z postaci posiada stały zestaw Umiejętności,
      wpływających na sprawność wykonywania konkretnych działań, Atrybutów, będących stałymi parametrami, niewpływającymi
      na wykonywanie czynności oraz Opis, krótko informujący gracza o osobistych cechach danej jednostki. Postać w danej
      chwili posiada także pewien Ekwipunek, Nastawienie oraz Stan. Niektóre wartości opisujące Stan są dynamicznie wyliczane,
      inne nie. Nastawienie jest parametrem ustawianym bezpośrednio przez gracza i mówi, jak dana postać reaguje na jednostki
      neutralne i wrogie. Postaci mogą chodzić po niezajętych przestrzeniach miejskich, przenosić konstrukcje obronne,
      przejmować budynki, sterować konstrukcjami obronnymi, walczyć ze sobą nawzajem i z tubylcami. W celu urozmaicenia
      gameplay'u, dążymy do możliwie dużej różnorodności w parametryzacji Umiejętności i Atrybutów postaci, tak aby każda
      z nich mogła mieć ciekawą, osobną historię fabularną i była użyteczna dla gracza w nieco inny sposób. Dzięki temu
      tworzymy wyraźne role poszczególnych postaci (medyk, inżynier, żołnierz, zwiadowca). Początkowo, każda z postaci
      ma ekwipunek, który został dla niej zdefiniowany na etapie tworzenia levelu.
    \paragraph{Tubylcy}
      Tubylcy są jednostkami podobnymi do postaci, w sensie zachowania na planszy. Wszyscy są sterowani przez proste AI.
      Posiadają tylko jeden rodzaj nastawienia, agresywny. Poruszają się w sposób mniej więcej losowy po całej planszy,
      atakując wszelkie spotkane postaci, niezależnie od tego, do jakiej należą one ekspedycji. Początkowo,
      niektórzy tubylcy mogą znajdować się w budynkach i wyjść z nich dopiero, kiedy ktoś się zbliży. Poziomy Atrybutów,
      Umiejętności i Ekwipunek poszczególnych Tubylców są generowane pół losowo na etapie tworzenia mapy.
    \paragraph{Przeszkody stałe}
      Przeszkody stałe są niezniszczalnymi elementami mapy. Tworzone są na poziomie edytowania levelu i nie udostępniają
      graczowi żadnej możliwej interakcji. Są nieruchomymi, nieprzepuszczalnymi obiektami fizycznymi, takimi jak: pomnik,
      ściana skalna, ruiny.
    \paragraph{Obozy}
      Obóz ekspedycji jest podstawowym obiektem dla każdej wyprawy. To w nim znajdują się zapasy pożywienia, to w nim tworzy
      się konstrukcje obronne i do niego trafiają wszystkie znalezione w budynkach przedmioty. Interakcja postaci z obozem
      możliwa jest tylko, gdy znajduje się ona odpowiednio blisko. Jest ona wtedy automatycznie leczona i regeneruje się
      jej zdrowie psychiczne. Obozy, tak jak konstrukcje obronne, mogą być składane i przenoszone w inne miejsce. W tym czasie,
      niemożliwe jest korzystanie z ich zawartości. Zniszczenie obozu automatycznie powoduje spadek ilości pożywienia danej
      ekspedycji do 0, co kończy się śmiercią głodową wszystkich postaci, o ile nie zdążą one wykonać swojej misji. 
    \paragraph{Przedmioty}
      Przedmioty w grze mogą znajdować się w jednym z 3 miejsc: w budynku (przed znalezieniem), w ekwipunku bazy lub w
      ekwipunku konkretnej postaci. Dzielimy je na 3 główne kategorie: przedmioty użytkowe, elementy do tworzenia konstrukcji
      obronnych, złożone konstrukcje.
      

  
  \section{Interfejs}
%   Krótko o ogólnych założeniach

  \section{Grafika}
%   Krótko o perspektywie, dlaczego taka, jakie to ma konsekwencje
    Świat rysowany w grze przedstawiony jest w uproszczonym wariancie perspektywy izometrycznej, często spotykanym w 
    wielu produkcjach z gatunku RPG. Gdyby spojrzeć na mapę gry idealnie z góry, to aby uzyskać naszą perspektywę należy
    ją obrócić względem środka o $45\degree$, a następnie pochylić w dół o $30\degree$.
    
    TODO: Tutaj chyba potrzebny jest jakiś rysunek? Czy ujdzie bez niego?
    
    Przedstawienie świata w ten sposób daje wrażenie trzech wymiarów, mimo w pełni dwuwymiarowego rysowania. Tekstury
    postaci, budynków, elementów mapy i samego podłoża muszą być przygotowane w przyjętej perspektywie, ale na poziomie
    zawartości kończy się większość komplikacji. Jedną z konsekwencji przyjętego rzutu jest konieczność tłumaczenia
    współrzędnych między ekranowymi i logicznymi. Zajmuje się tym klasa Viewport z modułu UserInterface. Więcej 
    informacji na ten temat znajduje się w odpowiednim rozdziale w dalszej części pracy. 
    
    Dla lepszego imitowania trzech wymiarów, założyliśmy że każdy obiekt w grze może być zwrócony w jednym z 8 kierunków
    (co $45\degree$). Oznacza to, że (w większości przypadków) dla każdego kierunku muszą być przygotowane osobne
    grafiki.
 
  \section{Analiza podobnych gier}

\chapter{Narzędzia i metodologia pracy}
  \section{Użyte biblioteki}
%   Analiza dlaczego te a nie inne (może tu, może dla każdej biblioteki porównanie z konkurencją)
    \subsection{Qt}
    
    \subsection{SFML}
    
    \subsection{Box2D}

  \section{Metodologia pracy}
%   jak korzystaliśmy z repo, robienie ustaleń per moduł w google docach, spotkania, asana
  
\chapter{Architektura}
% tutaj dane, formaty, diagram klas, algorytmy, moduły
  \section{Moduł ``General''}
  
  \section{Moduł ``Game Objects''}
  
  \section{Moduł ``Mind''}
  
  \section{Moduł ``Data Manager''}
  
  \section{Moduł ``Physics Engine''}
  
  \section{Moduł ``Graphics''}
    \subsection{Logiczny podział}
      Moduł $Graphics$ składa się z głownej klasy $Graphics$ odpowiedzialnej za wysokopoziomową logikę rysowania świata,
      hierarchii klas bazującej na $GraphicalEntity$, której nieabstrakcyjne instancje reprezentują obiekty w grze 
      (jednostki, budynki, przeszkody itd.), hierarchii klas bazującej na $GraphicalEffect$, której nieabstrakcyjne
      instancje reprezentują graficzne efekty towarzyszące wybranym $GraphicalEntity$ (np. zaznaczenie jednostki, 
      różne efekty debugowe itd.), hierarchii klas bazującej na $Decal$, której nieabstrakcyjne instancje zawierają
      logikę rysowania konkrentego rodzaju decali (np. krwi, więcej w subsekcji $Decals$), klasy $GraphicsDataManager$ 
      zarządzającej teksturami i czcionkami załadowanymi do pamięci karty graficznej oraz kilku klas pomocniczych 
      (fabryki klas, logika rysowania prostych kształtów itp.).
      
      Głównym założeniem modułu $Graphics$ było, aby logika była od niego kompletnie niezależna. Było to spowodowane
      naszą początkową niepewnością co do słuszności wyboru SFMLa jako frameworku do rysowania oraz całego konceptu
      pisania graficznej części silnika właściwie od podstaw. Drugorzędowym powodem tej decyzji była możliwość
      kompletnej zmiany koncepcyjnej gry małym kosztem - wystarczy napisać moduł graficzny realizujący inne wyświetlanie
      (np. w pełni 3D lub roguelike w konsoli), przekazać mu dane z logiki i otrzymujemy zupełnie inną wizualnie grę bez
      żadnych zmian w logice (oczywiście może to też wymagać mniejszych lub większych zmian w UI).
    
    \subsection{Rysowanie}
      Koncepcyjnie, logika $Graphics$ jest stosunkowo prosta: pobierz listę aktualnie widocznych obiektów z logiki 
      (używając modułu fizycznego), usuń z niej obiekty niewidoczne (przesłonięte mgłą wojny itd.), dodaj potrzebne 
      efekty i narysuj wszystko w poprawnej kolejności, dodając po drodze FOW, licznik FPS itd. Oczywiście wiele
      szczegółów zależnych od SFMLa, ograniczeń kart graficznych itd. leży zaszytych w hierarchii klas obiektów oraz w
      klasach pomocniczych, natomiast opisana wyżej prosta logika jest w tej formie zawarta w klasie $Graphics$, co
      bardzo ułatwia utrzymywanie tej części kodu.
      
      \subsubsection{Rysowanie mapy}
	Ze względu na łatwiejszą edycję podłoża mapy, zdecydowaliśmy się trzymać całe podłoże w jednym dużym pliku
	graficznym. W $Graphics$ jest to po prostu tekstura załadowana do pamięci karty graficznej, wyświetlana na 
	odpowiedniej warstwie. Jako że z punktu widzenia projektowania leveli nie było potrzeby tworzenia przesadnie
	dużych map, nie dzielimy tej tekstury na mniejsze. Taka zmiana, gdyby okazała się kiedykolwiek potrzebna,
	jest zmianą kosmetyczną i w całości po stronie $Graphics$.
      
    \subsection{Zarządzanie pamięcią}
      Grę pisaliśmy przyrostowo, wychodząc z założenia, że raczej nie chcemy przesadnie komplikować nowych
      funkcjonalności dopóki nie zajdzie taka potrzeba. W podobnym duchu powstawał $GraphicsDataManager$ - klasa
      zarządzająca zasobami trzymanymi w pamięci karty graficznej (tekstury i czcionki używane przez grafikę). Budowa
      rzeczonej klasy zakłada, że w przyszłości może być potrzebne jakiegoś rodzaju czyszczenie pamięci, aby pozbywać
      się nieużywanych danych w celu zwolnienia miejsca na nowe. W tym celu zliczane są użycia zasobów udostępnianych
      przez klasę. Gdyby w którymś momencie rozwoju projektu okazało się, że potrzebujemy pochylić się nad zużyciem
      pamięci karty graficznej, wystarczyłoby wykorzystać istniejący mechanizm.
      
      Dodatkowo, $GraphicsDataManager$ ładuje tekstury do pamięci karty graficznnej dopiero jeśli są potrzebne do
      wyświetlenia jakiegoś obiektu. Początkowo mieliśmy wątpliwości co do wydajności tego rozwiązania, ale praktyczne
      testy pokazały, że takie doładowywanie tekstur z pamięci RAM do pamięci karty jest niezauważalne.
      
    \subsection{Entities}
      Każdy obiekt, który ma się pojawić na ekranie (graficzna reprezentacja podklasy $Object$ lub efekt niezwiązany
      z konkretnym obiektem) jest w $GraphicalEffectFactory$ tłumaczony na instancję jakiejś podklasy $GraphicalEntity$
      i na dopiero na takich obiektach operuje klasa $Graphics$. Każda podklasa $GraphicalEntity$ umie się sama
      narysować w tym. np. wybrać poprawną klatkę animacji lub narysować jakiś prosty geometryczny kształt.
      
    \subsection{Effects}
      W grze potrzebowaliśmy często wyświetlać różne efekty, które nie są same z siebie $Object$ami, a co najwyżej
      towarzyszą jakimś $Object$om (np. efekt zaznaczenia jednostki) lub są w ogóle niezależne (np. efekt kursora po
      wydaniu komendy ruchu). Do rysowania efektów służa podklasy $GraphicalEffect$. Każda podklasa umie się narysować
      używając danych odn. obiektu któremu towarzyszą oraz dodatkowych parametrów. Efekty niezwiązane z żadnymi 
      $Object$ami są rozwiązane przez wielodziedziczenie - wszystkie tego typu efekty dziedziczą po 
      $GraphicalEffectEntity$, które dziedziczy po $GraphicalEffect$ oraz jednym z $GraphicalEntity$. Dzięki temu takie
      efekty, umieją zainicjować się danymi właściwymi dla efektów, jednocześnie mogąc być w grafice traktowane jak 
      zwykłe obiekty, m.in. można bez zmiany kodu decydować czy są widoczne oraz ustalać kolejność ich rysowania.
      
    \subsection{Decals}
      Decale w grach to wszelkiego rodzaju tekstury wrysowywane na powierzchni różnych obiektów, aby dodać np. dziurę
      po strzale, ślad krwi, symbol, dodatkowy element wizualny itp. na powierzchni jakiegoś oteksturowanego już obiektu
      bez potrzeby zmian tej tekstury. W naszym projekcie również wprowadziliśmy pewien system decali, służący do
      rysowania w zamyśle tylko po teksturze mapy. Wykorzystujemy go do rysowania śladów krwi po trafionych strzałach, 
      ale z powodzeniem można go wykorzystać do rysowania np. śladów po wybuchach, śladów po kulach na ziemi, itd. Ze
      względu na wydajność, decale wrysowywujemy bezpośrednio w teksturę mapy. Wybieraniem, instancjonowaniem oraz
      zlecaniem wrysowywania $Decal$i zajmuje się $DecalManager$ na polecenie $Graphics$.
      
    \subsection{Fog of War}
      Rysowaniem FOW zajmuje się klasa $GraphicalFogOfWar$. Obie warstwy FOW (obszar kiedykolwiek odkryty oraz obszar
      widoczny teraz) są trzymane na dosyć małych teksturach ze względu na stosunkowo mały minimalny maksymalny
      rozmiar tekstury na niektórych kartach graficznych (nawet rzędu $1024 \times 1024$ pikseli). Aby wyświetlić z 
      tych małych reprezentacji wizualnie atrakcyjny efekt końcowy, po przeskalowaniu tekstur na rozmiar ekranu 
      (i uprzednim wykadrowaniu interesującego nas fragmentu), aplikowane są do nich shadery realizujące Gaussowskie
      rozmycie. W ten sposób uzyskujemy ładny efekt wizualny przy okazji zmniejszając istotnie ilość danych przesyłanych
      do karty graficznej oraz obchodząc potencjalne ograniczenia słabszych układów.
      
  \section{Moduł ``User Interface''}
% Napisać o viewporcie kilka słów, że jesteśmy super i mamy taką klasę z podstawialnymi perspektywami, dzięki czemu cała
% logika przeliczania współrzędnych między różnymi reprezentacjami jest w jednym miejscu i wgl. jesteśmy uberkoderami.
  
  \section{Pozostałe moduły}
    \subsection{Moduł ``Common''}
    
    \subsection{Moduł ``Debug Manager''}

\chapter{Playtesty}
  \section{Cel}
%   Docelowo, od~momentu rozpoczęcia playtestów, cały cykl deweloperski będzie podyktowany 
%   kolejnymi iteracjami: playtesty - wnioski - produkcja. Wraz z~postępami w projekcie, 
%   coraz większy nacisk będzie kładziony na doznania gracza i~zbalansowanie gry. 
%   Wstępnie planowane są~3~serie playtestów, pierwsza testująca ogólną mechanikę i~interfejs,
%   druga sprawdzająca szczegółowo wszystkie mechanizmy gry, trzecia, końcowa, mająca na celu dopracowanie wersji alfa gry.
%   Istotnym elementem każdego playtestu jest uzyskanie informacji zwrotnej od~nowych testerów, nieznających koncepcji gry.
    
    \section{Testy mechaniki i interfejsu (Faza I)}
    Pierwsza faza testów została przeprowadzona na surowej wersji gry, 
    z~niepełnym zestawem funkcjonalności i~prototypowymi fragmentami grafiki. 
    Był to ostatni moment na~poważne zmiany mechaniki lub~dodanie nowych funkcji silnika.
      
      \subsection{Założenia i cele}
      Ta faza testów została zrealizowana na~podstawie ówczesnej wersji deweloperskiej, 
      bez~robienia specjalnej wersji wyłącznie do~tego celu. Jej głownym zadaniem jest 
      wykazanie błędów w~logice zachowania oraz~sprawdzenie wygody i~intuicyjności interfejsu. 
      Pomniejszym celem jest otrzymanie feedbacku od graczy na temat klimatu gry
      i~ewentualnych funkcjonalności, które poprawiłyby jakość końcowego produktu.
      
      \subsection{Forma}
      Testy gry na tym etapie składały się z~dwóch części, samodzielnej 15-20 min gry
      oraz swobodnej rozgrywce z dozwoloną ingerencją koordynatora.
      
      Pierwsza część testu polegała na indywidualnej grze na ówcześnie gotowej planszy.
      Każdy gracz otrzymał wydrukowaną instrukcję gry (zawierającej sterowanie i~wstęp fabularny)
      i~powinien był sam zrozumieć cel i~zasady gry. W~tym czasie, zespół udzielał minimalną liczbę
      podpowiedzi (wyłącznie w przypadku wyraźnych problemów gracza z rozgrywką) i~nie ingerował w~test.
      Zadaniem koordynatorów w~tej części było odnotowywanie reakcji gracza. 
      Po ukończeniu rozgrywki gracz wykorzystując stosowną ankietę przepytywał gracza na temat 
      jego ogólnego odbioru gry i~wcześniejszego doświadczenia z~grami. 
      
      Druga część wyglądała podobnie do~pierwszej, jednak zadaniem gracza było wykazanie 
      jak największej liczby błędów i~nieintuicyjnych mechanizmów gry. 
      Podczas tej części zespół na~bieżąco odpowiadał na pytania uczestników,
      a~także zadawał pytania o~opinie i~uwagi gracza na temat poszczególnych funkcjonalności
      lub~prosił o~wykonanie konkretnych zadań (np. otwarcie okna ekwipunku postaci).

      \subsection{Ankiety}
      Każdy koordynator był~wyposażony w~3~formularze:
      \begin{enumerate}
	\item arkusz do~wpisywania obserwacji,
	\item arkusz do~notowania błędów i~problemów,
	\item ankieta z~pytaniami do~testera.
      \end{enumerate}
      Każdy tester otrzymywał instrukcję zawierającą sterowanie i~wstęp fabularny.
      
      \noindent
      Wymienione formularze oraz~instrukcja znajdują się na~końcu pracy.

    \section{Testy grywalności i interfejsu (Faza II)}
    
      \subsection{Założenia i cele}
      
      \subsection{Forma}
    
      \subsection{Ankiety}
      Każdy koordynator był~wyposażony w~2~formularze:
      \begin{enumerate}
	\item arkusz do~wpisywania obserwacji,
	\item ankieta z~pytaniami do~testera.
      \end{enumerate}
      
      \noindent
      Wymienione formularze znajdują się na~końcu pracy.

\chapter{Kamienie milowe}
  \section{Podstawowy silnik gry}
  
  \section{Pierwsza grywalna wersja}
  
  \section{Druga grywalna wersja}
  system questów,
  pathfinding,
  2-ga mapa obrona, konstrukcje, początkowo, element
  poprawa interfejsu (dodanie notyfikacji)

\chapter{Wkład własny w powstały system}

  \section{Jan Darowski}

  \section{Piotr Majcherczyk}

  \section{Rafał Soszyński}

  \section{Tomasz Zakrzewski}

\chapter{Rezultat}

  \section{Zrealizowane funkcjonalności}

  \section{Niezrealizowane funkcjonalności}

  \section{Opinie testerów}

  \section{Opinia klienta}
  
  \section{Podsumowanie autorów}

\appendix

  \chapter{Przykładowe zrzuty ekranu}

  \chapter{Materiały do playtestów}
  Na kolejnych stronach znajdują się ankiety używane podczas playtestów
  oraz~instrukcja gry wręczana testerom.

    \includepdf[pages={-}]{Formularze-playtesty.pdf}
    \includepdf[pages={-}]{Instrukcje-do-playtestow.pdf}
    \includepdf[pages={-}]{Formularze-playtesty2.pdf}

  \chapter{Zawarość płyty CD}


\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

  \item{coś tam}

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: utf8
%%% End:
